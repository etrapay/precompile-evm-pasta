// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package pallas

import (
	"errors"
	"fmt"
	"math/big"

	"github.com/ava-labs/precompile-evm/lib"
	"github.com/ava-labs/subnet-evm/accounts/abi"
	"github.com/ava-labs/subnet-evm/precompile/contract"

	_ "embed"

	"github.com/ethereum/go-ethereum/common"
)

const (
	// Gas costs for each function. These are set to 1 by default.
	// You should set a gas cost for each function in your contract.
	// Generally, you should not set gas costs very low as this may cause your network to be vulnerable to DoS attacks.
	// There are some predefined gas costs in contract/utils.go that you can use.
	AffineAddGasCost               uint64 = 100 /* SET A GAS COST HERE */
	AffineGeneratorGasCost         uint64 = 100 /* SET A GAS COST HERE */
	DoubleGasCost                  uint64 = 100 /* SET A GAS COST HERE */
	DoubleAffineGasCost            uint64 = 100 /* SET A GAS COST HERE */
	DoubleProjectiveGasCost        uint64 = 100 /* SET A GAS COST HERE */
	FromLeBytesModOrderGasCost     uint64 = 100 /* SET A GAS COST HERE */
	InverseModGasCost              uint64 = 100 /* SET A GAS COST HERE */
	IsInfinityAffineGasCost        uint64 = 100 /* SET A GAS COST HERE */
	IsInfinityProjectiveGasCost    uint64 = 100 /* SET A GAS COST HERE */
	IsOnCurveGasCost               uint64 = 100 /* SET A GAS COST HERE */
	MulWithScalarAffineGasCost     uint64 = 100 /* SET A GAS COST HERE */
	MulWithScalarProjectiveGasCost uint64 = 100 /* SET A GAS COST HERE */
	NegateAffineGasCost            uint64 = 100 /* SET A GAS COST HERE */
	NegateProjectiveGasCost        uint64 = 100 /* SET A GAS COST HERE */
	NegateScalarGasCost            uint64 = 100 /* SET A GAS COST HERE */
	PowSmallGasCost                uint64 = 100 /* SET A GAS COST HERE */
	ProjectiveAddGasCost           uint64 = 100 /* SET A GAS COST HERE */
	ProjectiveGeneratorGasCost     uint64 = 100 /* SET A GAS COST HERE */
	ToAffineGasCost                uint64 = 100 /* SET A GAS COST HERE */
	ToProjectiveGasCost            uint64 = 100 /* SET A GAS COST HERE */
	ValidateScalarFieldGasCost     uint64 = 100 /* SET A GAS COST HERE */
)

// CUSTOM CODE STARTS HERE
// Reference imports to suppress errors from unused imports. This code and any unnecessary imports can be removed.
var (
	_ = abi.JSON
	_ = errors.New
	_ = big.NewInt
)

// Singleton StatefulPrecompiledContract and signatures.
var (

	// PallasRawABI contains the raw ABI of Pallas contract.
	//go:embed contract.abi
	PallasRawABI string

	PallasABI = contract.ParseABI(PallasRawABI)

	PallasPrecompile = createPallasPrecompile()

	curve lib.PallasCurve
)

// IPallasAffinePoint is an auto generated low-level Go binding around an user-defined struct.
type IPallasAffinePoint struct {
	X *big.Int
	Y *big.Int
}

// IPallasProjectivePoint is an auto generated low-level Go binding around an user-defined struct.
type IPallasProjectivePoint struct {
	X *big.Int
	Y *big.Int
	Z *big.Int
}

type AffineAddInput struct {
	P IPallasAffinePoint
	Q IPallasAffinePoint
}

type AffineAddOutput struct {
	R       IPallasAffinePoint
	Success bool
}

type DoubleAffineOutput struct {
	R       IPallasAffinePoint
	Success bool
}

type DoubleProjectiveOutput struct {
	R       IPallasProjectivePoint
	Success bool
}

type InverseModInput struct {
	Fr *big.Int
	M  *big.Int
}

type MulWithScalarAffineInput struct {
	P      IPallasAffinePoint
	Scalar *big.Int
}

type MulWithScalarAffineOutput struct {
	R       IPallasAffinePoint
	Success bool
}

type MulWithScalarProjectiveInput struct {
	P      IPallasProjectivePoint
	Scalar *big.Int
}

type MulWithScalarProjectiveOutput struct {
	R       IPallasProjectivePoint
	Success bool
}

type NegateAffineOutput struct {
	R       IPallasAffinePoint
	Success bool
}

type NegateProjectiveOutput struct {
	R       IPallasProjectivePoint
	Success bool
}

type PowSmallInput struct {
	Base     *big.Int
	Exponent *big.Int
	Modulus  *big.Int
}

type ProjectiveAddInput struct {
	P IPallasProjectivePoint
	Q IPallasProjectivePoint
}

type ProjectiveAddOutput struct {
	R       IPallasProjectivePoint
	Success bool
}

type ToAffineOutput struct {
	R       IPallasAffinePoint
	Success bool
}

type ToProjectiveOutput struct {
	R       IPallasProjectivePoint
	Success bool
}

// UnpackAffineAddInput attempts to unpack [input] as AffineAddInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackAffineAddInput(input []byte) (AffineAddInput, error) {
	inputStruct := AffineAddInput{}
	err := PallasABI.UnpackInputIntoInterface(&inputStruct, "affineAdd", input)

	return inputStruct, err
}

// PackAffineAdd packs [inputStruct] of type AffineAddInput into the appropriate arguments for affineAdd.
func PackAffineAdd(inputStruct AffineAddInput) ([]byte, error) {
	return PallasABI.Pack("affineAdd", inputStruct.P, inputStruct.Q)
}

// PackAffineAddOutput attempts to pack given [outputStruct] of type AffineAddOutput
// to conform the ABI outputs.
func PackAffineAddOutput(outputStruct AffineAddOutput) ([]byte, error) {
	return PallasABI.PackOutput("affineAdd",
		outputStruct.R,
		outputStruct.Success,
	)
}

func affineAdd(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, AffineAddGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the AffineAddInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackAffineAddInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p1, p2 lib.AffinePoint
	p1.X = inputStruct.P.X
	p1.Y = inputStruct.P.Y

	p2.X = inputStruct.Q.X
	p2.Y = inputStruct.Q.Y

	r, success := lib.AffineAddition(curve, p1, p2)

	output := AffineAddOutput{
		R: IPallasAffinePoint{
			X: r.X,
			Y: r.Y,
		},
		Success: success,
	}

	packedOutput, err := PackAffineAddOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// PackAffineGenerator packs the include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackAffineGenerator() ([]byte, error) {
	return PallasABI.Pack("affineGenerator")
}

// PackAffineGeneratorOutput attempts to pack given g of type IPallasAffinePoint
// to conform the ABI outputs.
func PackAffineGeneratorOutput(g IPallasAffinePoint) ([]byte, error) {
	return PallasABI.PackOutput("affineGenerator", g)
}

func affineGenerator(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, AffineGeneratorGasCost); err != nil {
		return nil, 0, err
	}

	r := curve.AffineGenerator()
	output := IPallasAffinePoint{
		X: r.X,
		Y: r.Y,
	}

	packedOutput, err := PackAffineGeneratorOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackDoubleInput attempts to unpack [input] into the IPallasAffinePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackDoubleInput(input []byte) (IPallasAffinePoint, error) {
	res, err := PallasABI.UnpackInput("double", input)
	if err != nil {
		return IPallasAffinePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasAffinePoint)).(*IPallasAffinePoint)
	return unpacked, nil
}

// UnpackDoubleAffineInput attempts to unpack [input] into the IPallasAffinePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackDoubleAffineInput(input []byte) (IPallasAffinePoint, error) {
	res, err := PallasABI.UnpackInput("doubleAffine", input)
	if err != nil {
		return IPallasAffinePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasAffinePoint)).(*IPallasAffinePoint)
	return unpacked, nil
}

// PackDoubleAffine packs [p] of type IPallasAffinePoint into the appropriate arguments for doubleAffine.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackDoubleAffine(p IPallasAffinePoint) ([]byte, error) {
	return PallasABI.Pack("doubleAffine", p)
}

// PackDoubleAffineOutput attempts to pack given [outputStruct] of type DoubleAffineOutput
// to conform the ABI outputs.
func PackDoubleAffineOutput(outputStruct DoubleAffineOutput) ([]byte, error) {
	return PallasABI.PackOutput("doubleAffine",
		outputStruct.R,
		outputStruct.Success,
	)
}

func doubleAffine(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, DoubleAffineGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the DoubleAffineInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackDoubleAffineInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.AffinePoint
	p.X, p.Y = inputStruct.X, inputStruct.Y

	r, success := lib.DoubleAffine(curve, p)

	output := DoubleAffineOutput{
		R: IPallasAffinePoint{
			X: r.X,
			Y: r.Y,
		},
		Success: success,
	}

	packedOutput, err := PackDoubleAffineOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackDoubleProjectiveInput attempts to unpack [input] into the IPallasProjectivePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackDoubleProjectiveInput(input []byte) (IPallasProjectivePoint, error) {
	res, err := PallasABI.UnpackInput("doubleProjective", input)
	if err != nil {
		return IPallasProjectivePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasProjectivePoint)).(*IPallasProjectivePoint)
	return unpacked, nil
}

// PackDoubleProjective packs [p] of type IPallasProjectivePoint into the appropriate arguments for doubleProjective.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackDoubleProjective(p IPallasProjectivePoint) ([]byte, error) {
	return PallasABI.Pack("doubleProjective", p)
}

// PackDoubleProjectiveOutput attempts to pack given [outputStruct] of type DoubleProjectiveOutput
// to conform the ABI outputs.
func PackDoubleProjectiveOutput(outputStruct DoubleProjectiveOutput) ([]byte, error) {
	return PallasABI.PackOutput("doubleProjective",
		outputStruct.R,
		outputStruct.Success,
	)
}

func doubleProjective(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, DoubleProjectiveGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the DoubleProjectiveInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackDoubleProjectiveInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.ProjectivePoint
	p.X, p.Y, p.Z = inputStruct.X, inputStruct.Y, inputStruct.Z

	res, success := lib.DoubleProjective(curve, p)
	output := DoubleProjectiveOutput{
		R: IPallasProjectivePoint{
			X: res.X,
			Y: res.Y,
			Z: res.Z,
		},
		Success: success,
	}

	packedOutput, err := PackDoubleProjectiveOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackFromLeBytesModOrderInput attempts to unpack [input] into the []byte type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackFromLeBytesModOrderInput(input []byte) ([]byte, error) {
	res, err := PallasABI.UnpackInput("fromLeBytesModOrder", input)
	if err != nil {
		return nil, err
	}
	unpacked := *abi.ConvertType(res[0], new([]byte)).(*[]byte)
	return unpacked, nil
}

// PackFromLeBytesModOrder packs [leBytes] of type []byte into the appropriate arguments for fromLeBytesModOrder.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackFromLeBytesModOrder(leBytes []byte) ([]byte, error) {
	return PallasABI.Pack("fromLeBytesModOrder", leBytes)
}

// PackFromLeBytesModOrderOutput attempts to pack given r of type *big.Int
// to conform the ABI outputs.
func PackFromLeBytesModOrderOutput(r *big.Int) ([]byte, error) {
	return PallasABI.PackOutput("fromLeBytesModOrder", r)
}

func fromLeBytesModOrder(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, FromLeBytesModOrderGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the FromLeBytesModOrderInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackFromLeBytesModOrderInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	leBytes := inputStruct

	output := lib.FromLeBytesModOrder(curve, leBytes)

	packedOutput, err := PackFromLeBytesModOrderOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackInverseModInput attempts to unpack [input] as InverseModInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackInverseModInput(input []byte) (InverseModInput, error) {
	inputStruct := InverseModInput{}
	err := PallasABI.UnpackInputIntoInterface(&inputStruct, "inverseMod", input)

	return inputStruct, err
}

// PackInverseMod packs [inputStruct] of type InverseModInput into the appropriate arguments for inverseMod.
func PackInverseMod(inputStruct InverseModInput) ([]byte, error) {
	return PallasABI.Pack("inverseMod", inputStruct.Fr, inputStruct.M)
}

// PackInverseModOutput attempts to pack given iFr of type *big.Int
// to conform the ABI outputs.
func PackInverseModOutput(iFr *big.Int) ([]byte, error) {
	return PallasABI.PackOutput("inverseMod", iFr)
}

func inverseMod(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, InverseModGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the InverseModInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackInverseModInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	fr, m := inputStruct.Fr, inputStruct.M // CUSTOM CODE OPERATES ON INPUT

	output := lib.InverseMod(fr, m)
	packedOutput, err := PackInverseModOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackIsInfinityAffineInput attempts to unpack [input] into the IPallasAffinePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackIsInfinityAffineInput(input []byte) (IPallasAffinePoint, error) {
	res, err := PallasABI.UnpackInput("isInfinityAffine", input)
	if err != nil {
		return IPallasAffinePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasAffinePoint)).(*IPallasAffinePoint)
	return unpacked, nil
}

// PackIsInfinityAffine packs [p] of type IPallasAffinePoint into the appropriate arguments for isInfinityAffine.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackIsInfinityAffine(p IPallasAffinePoint) ([]byte, error) {
	return PallasABI.Pack("isInfinityAffine", p)
}

// PackIsInfinityAffineOutput attempts to pack given r of type bool
// to conform the ABI outputs.
func PackIsInfinityAffineOutput(r bool) ([]byte, error) {
	return PallasABI.PackOutput("isInfinityAffine", r)
}

func isInfinityAffine(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, IsInfinityAffineGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the IsInfinityAffineInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackIsInfinityAffineInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.AffinePoint

	p.X, p.Y = inputStruct.X, inputStruct.Y

	output := p.IsInfinity()

	packedOutput, err := PackIsInfinityAffineOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackIsInfinityProjectiveInput attempts to unpack [input] into the IPallasProjectivePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackIsInfinityProjectiveInput(input []byte) (IPallasProjectivePoint, error) {
	res, err := PallasABI.UnpackInput("isInfinityProjective", input)
	if err != nil {
		return IPallasProjectivePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasProjectivePoint)).(*IPallasProjectivePoint)
	return unpacked, nil
}

// PackIsInfinityProjective packs [p] of type IPallasProjectivePoint into the appropriate arguments for isInfinityProjective.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackIsInfinityProjective(p IPallasProjectivePoint) ([]byte, error) {
	return PallasABI.Pack("isInfinityProjective", p)
}

// PackIsInfinityProjectiveOutput attempts to pack given r of type bool
// to conform the ABI outputs.
func PackIsInfinityProjectiveOutput(r bool) ([]byte, error) {
	return PallasABI.PackOutput("isInfinityProjective", r)
}

func isInfinityProjective(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, IsInfinityProjectiveGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the IsInfinityProjectiveInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackIsInfinityProjectiveInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.ProjectivePoint
	// CUSTOM CODE STARTS HERE
	p.X, p.Y, p.Z = inputStruct.X, inputStruct.Y, inputStruct.Z

	output := p.IsInfinity()

	packedOutput, err := PackIsInfinityProjectiveOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackIsOnCurveInput attempts to unpack [input] into the IPallasAffinePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackIsOnCurveInput(input []byte) (IPallasAffinePoint, error) {
	res, err := PallasABI.UnpackInput("isOnCurve", input)
	if err != nil {
		return IPallasAffinePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasAffinePoint)).(*IPallasAffinePoint)
	return unpacked, nil
}

// PackIsOnCurve packs [p] of type IPallasAffinePoint into the appropriate arguments for isOnCurve.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackIsOnCurve(p IPallasAffinePoint) ([]byte, error) {
	return PallasABI.Pack("isOnCurve", p)
}

// PackIsOnCurveOutput attempts to pack given r of type bool
// to conform the ABI outputs.
func PackIsOnCurveOutput(r bool) ([]byte, error) {
	return PallasABI.PackOutput("isOnCurve", r)
}

func isOnCurve(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, IsOnCurveGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the IsOnCurveInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackIsOnCurveInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.AffinePoint

	p.X, p.Y = inputStruct.X, inputStruct.Y // CUSTOM CODE OPERATES ON INPUT

	output := lib.IsOnCurve(curve, p)
	packedOutput, err := PackIsOnCurveOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackMulWithScalarAffineInput attempts to unpack [input] as MulWithScalarAffineInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackMulWithScalarAffineInput(input []byte) (MulWithScalarAffineInput, error) {
	inputStruct := MulWithScalarAffineInput{}
	err := PallasABI.UnpackInputIntoInterface(&inputStruct, "mulWithScalarAffine", input)

	return inputStruct, err
}

// PackMulWithScalarAffine packs [inputStruct] of type MulWithScalarAffineInput into the appropriate arguments for mulWithScalarAffine.
func PackMulWithScalarAffine(inputStruct MulWithScalarAffineInput) ([]byte, error) {
	return PallasABI.Pack("mulWithScalarAffine", inputStruct.P, inputStruct.Scalar)
}

// PackMulWithScalarAffineOutput attempts to pack given [outputStruct] of type MulWithScalarAffineOutput
// to conform the ABI outputs.
func PackMulWithScalarAffineOutput(outputStruct MulWithScalarAffineOutput) ([]byte, error) {
	return PallasABI.PackOutput("mulWithScalarAffine",
		outputStruct.R,
		outputStruct.Success,
	)
}

func mulWithScalarAffine(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, MulWithScalarAffineGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the MulWithScalarAffineInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackMulWithScalarAffineInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.AffinePoint
	var scalar *big.Int
	p.X, p.Y, scalar = inputStruct.P.X, inputStruct.P.Y, inputStruct.Scalar

	// var output MulWithScalarAffineOutput // CUSTOM CODE FOR AN OUTPUT
	res, success := lib.MulWithScalarAffine(curve, p, scalar)
	output := MulWithScalarAffineOutput{
		R: IPallasAffinePoint{
			X: res.X,
			Y: res.Y,
		},
		Success: success,
	}

	packedOutput, err := PackMulWithScalarAffineOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackMulWithScalarProjectiveInput attempts to unpack [input] as MulWithScalarProjectiveInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackMulWithScalarProjectiveInput(input []byte) (MulWithScalarProjectiveInput, error) {
	inputStruct := MulWithScalarProjectiveInput{}
	err := PallasABI.UnpackInputIntoInterface(&inputStruct, "mulWithScalarProjective", input)

	return inputStruct, err
}

// PackMulWithScalarProjective packs [inputStruct] of type MulWithScalarProjectiveInput into the appropriate arguments for mulWithScalarProjective.
func PackMulWithScalarProjective(inputStruct MulWithScalarProjectiveInput) ([]byte, error) {
	return PallasABI.Pack("mulWithScalarProjective", inputStruct.P, inputStruct.Scalar)
}

// PackMulWithScalarProjectiveOutput attempts to pack given [outputStruct] of type MulWithScalarProjectiveOutput
// to conform the ABI outputs.
func PackMulWithScalarProjectiveOutput(outputStruct MulWithScalarProjectiveOutput) ([]byte, error) {
	return PallasABI.PackOutput("mulWithScalarProjective",
		outputStruct.R,
		outputStruct.Success,
	)
}

func mulWithScalarProjective(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, MulWithScalarProjectiveGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the MulWithScalarProjectiveInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackMulWithScalarProjectiveInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.ProjectivePoint
	p.X, p.Y, p.Z = inputStruct.P.X, inputStruct.P.Y, inputStruct.P.Z

	scalar := inputStruct.Scalar
	res, success := lib.MulWithScalarProjective(curve, p, scalar)

	output := MulWithScalarProjectiveOutput{
		R: IPallasProjectivePoint{
			X: res.X,
			Y: res.Y,
			Z: res.Z,
		},
		Success: success,
	}

	packedOutput, err := PackMulWithScalarProjectiveOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackNegateAffineInput attempts to unpack [input] into the IPallasAffinePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackNegateAffineInput(input []byte) (IPallasAffinePoint, error) {
	res, err := PallasABI.UnpackInput("negateAffine", input)
	if err != nil {
		return IPallasAffinePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasAffinePoint)).(*IPallasAffinePoint)
	return unpacked, nil
}

// PackNegateAffine packs [p] of type IPallasAffinePoint into the appropriate arguments for negateAffine.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackNegateAffine(p IPallasAffinePoint) ([]byte, error) {
	return PallasABI.Pack("negateAffine", p)
}

// PackNegateAffineOutput attempts to pack given [outputStruct] of type NegateAffineOutput
// to conform the ABI outputs.
func PackNegateAffineOutput(outputStruct NegateAffineOutput) ([]byte, error) {
	return PallasABI.PackOutput("negateAffine",
		outputStruct.R,
		outputStruct.Success,
	)
}

func negateAffine(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, NegateAffineGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the NegateAffineInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackNegateAffineInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.AffinePoint
	p.X, p.Y = inputStruct.X, inputStruct.Y

	r, success := lib.NegateAffine(curve, p)

	output := NegateAffineOutput{
		R: IPallasAffinePoint{
			X: r.X,
			Y: r.Y,
		},
		Success: success,
	}

	packedOutput, err := PackNegateAffineOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackNegateProjectiveInput attempts to unpack [input] into the IPallasProjectivePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackNegateProjectiveInput(input []byte) (IPallasProjectivePoint, error) {
	res, err := PallasABI.UnpackInput("negateProjective", input)
	if err != nil {
		return IPallasProjectivePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasProjectivePoint)).(*IPallasProjectivePoint)
	return unpacked, nil
}

// PackNegateProjective packs [p] of type IPallasProjectivePoint into the appropriate arguments for negateProjective.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackNegateProjective(p IPallasProjectivePoint) ([]byte, error) {
	return PallasABI.Pack("negateProjective", p)
}

// PackNegateProjectiveOutput attempts to pack given [outputStruct] of type NegateProjectiveOutput
// to conform the ABI outputs.
func PackNegateProjectiveOutput(outputStruct NegateProjectiveOutput) ([]byte, error) {
	return PallasABI.PackOutput("negateProjective",
		outputStruct.R,
		outputStruct.Success,
	)
}

func negateProjective(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, NegateProjectiveGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the NegateProjectiveInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackNegateProjectiveInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.ProjectivePoint
	p.X, p.Y, p.Z = inputStruct.X, inputStruct.Y, inputStruct.Z

	res, success := lib.NegateProjective(curve, p)
	output := NegateProjectiveOutput{
		R: IPallasProjectivePoint{
			X: res.X,
			Y: res.Y,
			Z: res.Z,
		},
		Success: success,
	}

	packedOutput, err := PackNegateProjectiveOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackNegateScalarInput attempts to unpack [input] into the *big.Int type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackNegateScalarInput(input []byte) (*big.Int, error) {
	res, err := PallasABI.UnpackInput("negateScalar", input)
	if err != nil {
		return big.NewInt(0), err
	}
	unpacked := *abi.ConvertType(res[0], new(*big.Int)).(**big.Int)
	return unpacked, nil
}

// PackNegateScalar packs [scalar] of type *big.Int into the appropriate arguments for negateScalar.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackNegateScalar(scalar *big.Int) ([]byte, error) {
	return PallasABI.Pack("negateScalar", scalar)
}

// PackNegateScalarOutput attempts to pack given nScalar of type *big.Int
// to conform the ABI outputs.
func PackNegateScalarOutput(nScalar *big.Int) ([]byte, error) {
	return PallasABI.PackOutput("negateScalar", nScalar)
}

func negateScalar(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, NegateScalarGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the NegateScalarInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackNegateScalarInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	s := inputStruct
	output := lib.NegateScalar(curve, s)

	packedOutput, err := PackNegateScalarOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackPowSmallInput attempts to unpack [input] as PowSmallInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackPowSmallInput(input []byte) (PowSmallInput, error) {
	inputStruct := PowSmallInput{}
	err := PallasABI.UnpackInputIntoInterface(&inputStruct, "powSmall", input)

	return inputStruct, err
}

// PackPowSmall packs [inputStruct] of type PowSmallInput into the appropriate arguments for powSmall.
func PackPowSmall(inputStruct PowSmallInput) ([]byte, error) {
	return PallasABI.Pack("powSmall", inputStruct.Base, inputStruct.Exponent, inputStruct.Modulus)
}

// PackPowSmallOutput attempts to pack given r of type *big.Int
// to conform the ABI outputs.
func PackPowSmallOutput(r *big.Int) ([]byte, error) {
	return PallasABI.PackOutput("powSmall", r)
}

func powSmall(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, PowSmallGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the PowSmallInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackPowSmallInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	base, exponent, modulus := inputStruct.Base, inputStruct.Exponent, inputStruct.Modulus
	output := lib.PowSmall(base, exponent, modulus)

	packedOutput, err := PackPowSmallOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackProjectiveAddInput attempts to unpack [input] as ProjectiveAddInput
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackProjectiveAddInput(input []byte) (ProjectiveAddInput, error) {
	inputStruct := ProjectiveAddInput{}
	err := PallasABI.UnpackInputIntoInterface(&inputStruct, "projectiveAdd", input)

	return inputStruct, err
}

// PackProjectiveAdd packs [inputStruct] of type ProjectiveAddInput into the appropriate arguments for projectiveAdd.
func PackProjectiveAdd(inputStruct ProjectiveAddInput) ([]byte, error) {
	return PallasABI.Pack("projectiveAdd", inputStruct.P, inputStruct.Q)
}

// PackProjectiveAddOutput attempts to pack given [outputStruct] of type ProjectiveAddOutput
// to conform the ABI outputs.
func PackProjectiveAddOutput(outputStruct ProjectiveAddOutput) ([]byte, error) {
	return PallasABI.PackOutput("projectiveAdd",
		outputStruct.R,
		outputStruct.Success,
	)
}

func projectiveAdd(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ProjectiveAddGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the ProjectiveAddInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackProjectiveAddInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p, q lib.ProjectivePoint

	p.X, p.Y, p.Z = inputStruct.P.X, inputStruct.P.Y, inputStruct.P.Z
	q.X, q.Y, q.Z = inputStruct.Q.X, inputStruct.Q.Y, inputStruct.Q.Z

	res, success := lib.ProjectiveAddition(curve, p, q)
	output := ProjectiveAddOutput{
		R: IPallasProjectivePoint{
			X: res.X,
			Y: res.Y,
			Z: res.Z,
		},
		Success: success,
	}

	packedOutput, err := PackProjectiveAddOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// PackProjectiveGenerator packs the include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackProjectiveGenerator() ([]byte, error) {
	return PallasABI.Pack("projectiveGenerator")
}

// PackProjectiveGeneratorOutput attempts to pack given g of type IPallasProjectivePoint
// to conform the ABI outputs.
func PackProjectiveGeneratorOutput(g IPallasProjectivePoint) ([]byte, error) {
	return PallasABI.PackOutput("projectiveGenerator", g)
}

func projectiveGenerator(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ProjectiveGeneratorGasCost); err != nil {
		return nil, 0, err
	}
	// no input provided for this function

	r := curve.ProjectiveGenerator()
	output := IPallasProjectivePoint{
		X: r.X,
		Y: r.Y,
	}

	packedOutput, err := PackProjectiveGeneratorOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackToAffineInput attempts to unpack [input] into the IPallasProjectivePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackToAffineInput(input []byte) (IPallasProjectivePoint, error) {
	res, err := PallasABI.UnpackInput("toAffine", input)
	if err != nil {
		return IPallasProjectivePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasProjectivePoint)).(*IPallasProjectivePoint)
	return unpacked, nil
}

// PackToAffine packs [p] of type IPallasProjectivePoint into the appropriate arguments for toAffine.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackToAffine(p IPallasProjectivePoint) ([]byte, error) {
	return PallasABI.Pack("toAffine", p)
}

// PackToAffineOutput attempts to pack given [outputStruct] of type ToAffineOutput
// to conform the ABI outputs.
func PackToAffineOutput(outputStruct ToAffineOutput) ([]byte, error) {
	return PallasABI.PackOutput("toAffine",
		outputStruct.R,
		outputStruct.Success,
	)
}

func toAffine(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ToAffineGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the ToAffineInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackToAffineInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.ProjectivePoint
	p.X, p.Y, p.Z = inputStruct.X, inputStruct.Y, inputStruct.Z

	res, success := lib.ToAffine(curve, p)
	output := ToAffineOutput{
		R: IPallasAffinePoint{
			X: res.X,
			Y: res.Y,
		},
		Success: success,
	}

	packedOutput, err := PackToAffineOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackToProjectiveInput attempts to unpack [input] into the IPallasAffinePoint type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackToProjectiveInput(input []byte) (IPallasAffinePoint, error) {
	res, err := PallasABI.UnpackInput("toProjective", input)
	if err != nil {
		return IPallasAffinePoint{}, err
	}
	unpacked := *abi.ConvertType(res[0], new(IPallasAffinePoint)).(*IPallasAffinePoint)
	return unpacked, nil
}

// PackToProjective packs [p] of type IPallasAffinePoint into the appropriate arguments for toProjective.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackToProjective(p IPallasAffinePoint) ([]byte, error) {
	return PallasABI.Pack("toProjective", p)
}

// PackToProjectiveOutput attempts to pack given [outputStruct] of type ToProjectiveOutput
// to conform the ABI outputs.
func PackToProjectiveOutput(outputStruct ToProjectiveOutput) ([]byte, error) {
	return PallasABI.PackOutput("toProjective",
		outputStruct.R,
		outputStruct.Success,
	)
}

func toProjective(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ToProjectiveGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the ToProjectiveInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackToProjectiveInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	var p lib.AffinePoint

	p.X, p.Y = inputStruct.X, inputStruct.Y

	res, success := lib.ToProjective(p)
	output := ToProjectiveOutput{
		R: IPallasProjectivePoint{
			X: res.X,
			Y: res.Y,
			Z: res.Z,
		},
		Success: success,
	}

	packedOutput, err := PackToProjectiveOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackValidateScalarFieldInput attempts to unpack [input] into the *big.Int type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackValidateScalarFieldInput(input []byte) (*big.Int, error) {
	res, err := PallasABI.UnpackInput("validateScalarField", input)
	if err != nil {
		return big.NewInt(0), err
	}
	unpacked := *abi.ConvertType(res[0], new(*big.Int)).(**big.Int)
	return unpacked, nil
}

// PackValidateScalarField packs [scalar] of type *big.Int into the appropriate arguments for validateScalarField.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackValidateScalarField(scalar *big.Int) ([]byte, error) {
	return PallasABI.Pack("validateScalarField", scalar)
}

// PackValidateScalarFieldOutput attempts to pack given r of type bool
// to conform the ABI outputs.
func PackValidateScalarFieldOutput(r bool) ([]byte, error) {
	return PallasABI.PackOutput("validateScalarField", r)
}

func validateScalarField(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, ValidateScalarFieldGasCost); err != nil {
		return nil, 0, err
	}
	// attempts to unpack [input] into the arguments to the ValidateScalarFieldInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackValidateScalarFieldInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	s := inputStruct
	output := curve.ValidateScalarField(s)

	packedOutput, err := PackValidateScalarFieldOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// createPallasPrecompile returns a StatefulPrecompiledContract with getters and setters for the precompile.

func createPallasPrecompile() contract.StatefulPrecompiledContract {
	// Initialize the curve
	curve.InitPallas()

	var functions []*contract.StatefulPrecompileFunction

	abiFunctionMap := map[string]contract.RunStatefulPrecompileFunc{
		"affineAdd":               affineAdd,
		"affineGenerator":         affineGenerator,
		"doubleAffine":            doubleAffine,
		"doubleProjective":        doubleProjective,
		"fromLeBytesModOrder":     fromLeBytesModOrder,
		"inverseMod":              inverseMod,
		"isInfinityAffine":        isInfinityAffine,
		"isInfinityProjective":    isInfinityProjective,
		"isOnCurve":               isOnCurve,
		"mulWithScalarAffine":     mulWithScalarAffine,
		"mulWithScalarProjective": mulWithScalarProjective,
		"negateAffine":            negateAffine,
		"negateProjective":        negateProjective,
		"negateScalar":            negateScalar,
		"powSmall":                powSmall,
		"projectiveAdd":           projectiveAdd,
		"projectiveGenerator":     projectiveGenerator,
		"toAffine":                toAffine,
		"toProjective":            toProjective,
		"validateScalarField":     validateScalarField,
	}

	for name, function := range abiFunctionMap {
		method, ok := PallasABI.Methods[name]
		if !ok {
			panic(fmt.Errorf("given method (%s) does not exist in the ABI", name))
		}
		functions = append(functions, contract.NewStatefulPrecompileFunction(method.ID, function))
	}
	// Construct the contract with no fallback function.
	statefulContract, err := contract.NewStatefulPrecompileContract(nil, functions)
	if err != nil {
		panic(err)
	}
	return statefulContract
}
